<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BikinMars - Carte en Temps R√©el</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <link rel="stylesheet" href="https://unpkg.com/leaflet.locatecontrol/dist/L.Control.Locate.min.css" />
    <script src="https://unpkg.com/leaflet.locatecontrol/dist/L.Control.Locate.min.js"></script>

    <style>
        html, body { margin: 0; height: 100%; font-family: sans-serif; }
        #map { width: 100%; height: 100%; }

        .leaflet-control-log {
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 13px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            margin: 10px;
            z-index: 1000;
        }

        .station-tooltip {
            background: transparent;
            border: none !important;
            box-shadow: none !important;
            color: white;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <script>
        // Configuration des URLs avec le nouveau proxy AllOrigins
        const proxy = "https://api.allorigins.win/raw?url=";
        const urlInfo = proxy + encodeURIComponent("https://gbfs.omega.fifteen.eu/gbfs/2.2/marseille/en/station_information.json");
        const urlStatus = proxy + encodeURIComponent("https://gbfs.omega.fifteen.eu/gbfs/2.2/marseille/en/station_status.json");
        const urlBikes = proxy + encodeURIComponent("https://gbfs.omega.fifteen.eu/gbfs/2.2/marseille/en/free_bike_status.json");

        // Initialisation de la carte
        const map = L.map("map").setView([43.2965, 5.3764], 13);
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            attribution: "&copy; OpenStreetMap contributors"
        }).addTo(map);

        // Ajout du bouton de g√©olocalisation
        L.control.locate({
            position: "topleft",
            strings: { title: "Me localiser" },
            flyTo: true
        }).addTo(map);

        // Overlay de statut (Log)
        const LogControl = L.Control.extend({
            onAdd: function(map) {
                this._div = L.DomUtil.create('div', 'leaflet-control-log');
                this._div.innerHTML = "Initialisation...";
                return this._div;
            },
            update: function(msg) {
                this._div.innerHTML = msg;
            }
        });
        const log = new LogControl({ position: 'bottomleft' }).addTo(map);

        async function loadData() {
            log.update("‚è≥ Mise √† jour...");

            try {
                const [infoRes, statusRes, bikesRes] = await Promise.all([
                    fetch(urlInfo).then(r => r.json()),
                    fetch(urlStatus).then(r => r.json()),
                    fetch(urlBikes).then(r => r.json())
                ]);

                // V√©rification que les donn√©es sont valides
                if (!infoRes.data || !statusRes.data) {
                    throw new Error("Donn√©es GBFS introuvables");
                }

                const stationsInfo = infoRes.data.stations;
                const stationsStatus = statusRes.data.stations;
                const freeBikes = bikesRes.data.bikes || [];

                const stations = {};

                // 1. Pr√©parer les infos de base
                stationsInfo.forEach(s => {
                    stations[s.station_id] = {
                        name: s.name,
                        lat: s.lat,
                        lon: s.lon,
                        bikes: 0,
                        docks: 0
                    };
                });

                // 2. Ajouter les disponibilit√©s en temps r√©el
                stationsStatus.forEach(s => {
                    if (stations[s.station_id]) {
                        stations[s.station_id].bikes = s.num_bikes_available;
                        stations[s.station_id].docks = s.num_docks_available;
                    }
                });

                // 3. Mapper les v√©los libres (batterie, etc.)
                const bikesByStation = {};
                freeBikes.forEach(b => {
                    if (b.station_id) {
                        const range = Math.round((b.current_range_meters / 45000) * 100);
                        const detail = `üö≤ Bat: ${range}% ${b.is_disabled ? '‚ö†Ô∏è Cass√©' : ''}`;
                        if (!bikesByStation[b.station_id]) bikesByStation[b.station_id] = [];
                        bikesByStation[b.station_id].push(detail);
                    }
                });

                // Nettoyage de l'ancienne couche
                if (window.stationLayer) map.removeLayer(window.stationLayer);
                window.stationLayer = L.layerGroup().addTo(map);

                // 4. Affichage des marqueurs
                Object.entries(stations).forEach(([id, st]) => {
                    const nbVelo = st.bikes;
                    let popupContent = `<b>${st.name}</b><br>üö≤ ${nbVelo} v√©los<br>üÖøÔ∏è ${st.docks} places`;
                    
                    if (bikesByStation[id]) {
                        popupContent += `<hr><b>D√©tails :</b><br>${bikesByStation[id].slice(0, 5).join('<br>')}`;
                    }

                    const marker = L.circleMarker([st.lat, st.lon], {
                        radius: 14,
                        color: '#E94E1B',
                        fillColor: '#E94E1B',
                        fillOpacity: 0.8,
                        weight: 0
                    }).addTo(window.stationLayer);

                    marker.bindPopup(popupContent);
                    marker.bindTooltip(`${nbVelo}`, {
                        permanent: true,
                        direction: 'center',
                        className: 'station-tooltip'
                    });
                });

                log.update("‚úÖ Mis √† jour √† " + new Date().toLocaleTimeString());

            } catch (err) {
                console.error(err);
                log.update("‚ùå Erreur de connexion au flux");
            }
        }

        // Chargement initial et rafra√Æchissement auto
        loadData();
        setInterval(loadData, 60000); // Toutes les minutes
    </script>
</body>
</html>
